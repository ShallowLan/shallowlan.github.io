<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你好，欢迎来到何明暄的笔记</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="这是我的第一个VuePress站点">
    
    <link rel="preload" href="/lan-blog-vuepress/assets/css/0.styles.2e8ecb9c.css" as="style"><link rel="preload" href="/lan-blog-vuepress/assets/js/app.f42ab384.js" as="script"><link rel="preload" href="/lan-blog-vuepress/assets/js/2.f6fab634.js" as="script"><link rel="preload" href="/lan-blog-vuepress/assets/js/9.6294dd7e.js" as="script"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/10.20c6e967.js"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/11.51f810ab.js"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/12.d959141f.js"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/3.8992f44d.js"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/4.a2a22d24.js"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/5.75a3592b.js"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/6.0377ba0c.js"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/7.b2034683.js"><link rel="prefetch" href="/lan-blog-vuepress/assets/js/8.2b8c70ed.js">
    <link rel="stylesheet" href="/lan-blog-vuepress/assets/css/0.styles.2e8ecb9c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/lan-blog-vuepress/" class="home-link router-link-active"><img src="https://vuejs.org/images/logo.png" alt="你好，欢迎来到何明暄的笔记" class="logo"> <span class="site-name can-hide">你好，欢迎来到何明暄的笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/lan-blog-vuepress/" class="nav-link">
  概述
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue 学习笔记" class="dropdown-title"><span class="title">Vue 学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue 学习笔记" class="mobile-dropdown-title"><span class="title">Vue 学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lan-blog-vuepress/guide/vue3/test.html" class="nav-link">
  笔记
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  其它链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Typescript 学习笔记" class="dropdown-title"><span class="title">Typescript 学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="Typescript 学习笔记" class="mobile-dropdown-title"><span class="title">Typescript 学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  其它链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/lan-blog-vuepress/" class="nav-link">
  概述
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue 学习笔记" class="dropdown-title"><span class="title">Vue 学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue 学习笔记" class="mobile-dropdown-title"><span class="title">Vue 学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lan-blog-vuepress/guide/vue3/test.html" class="nav-link">
  笔记
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  其它链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Typescript 学习笔记" class="dropdown-title"><span class="title">Typescript 学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="Typescript 学习笔记" class="mobile-dropdown-title"><span class="title">Typescript 学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  其它链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/lan-blog-vuepress/guide/vue3/api1.html" class="sidebar-link">总结Vue3及常用api</a></li><li><a href="/lan-blog-vuepress/guide/vue3/api2.html" class="sidebar-link">总结Vue3及常用api2</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/lan-blog-vuepress/guide/" aria-current="page" class="sidebar-link">js</a></li><li><a href="/lan-blog-vuepress/guide/js/bibao.html" aria-current="page" class="active sidebar-link">JavaScript闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/lan-blog-vuepress/guide/js/bibao.html#准备" class="sidebar-link">准备</a></li><li class="sidebar-sub-header"><a href="/lan-blog-vuepress/guide/js/bibao.html#词法作用域-lexical-scope" class="sidebar-link">词法作用域（Lexical scope）</a></li><li class="sidebar-sub-header"><a href="/lan-blog-vuepress/guide/js/bibao.html#返回函数的函数" class="sidebar-link">返回函数的函数</a></li><li class="sidebar-sub-header"><a href="/lan-blog-vuepress/guide/js/bibao.html#最后-一个闭包" class="sidebar-link">最后,一个闭包</a></li><li class="sidebar-sub-header"><a href="/lan-blog-vuepress/guide/js/bibao.html#闭包不是那么简单" class="sidebar-link">闭包不是那么简单</a></li><li class="sidebar-sub-header"><a href="/lan-blog-vuepress/guide/js/bibao.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>原文：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmedium.com%2Fdailyjs%2Fi-never-understood-javascript-closures-9663703368e8" title="https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8" target="_blank" rel="noopener noreferrer">medium.com/dailyjs/i-n…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>正如标题所述，JavaScript 闭包对我来说一直有点神秘,看过很多闭包的文章，在工作使用过闭包，有时甚至在项目中使用闭包，但我确实是这是在使用闭包的知识。</p> <p>最近看到的一些文章，终于，有人用于一种让我明白方式对闭包进行了解释，我将在本文中尝试使用这种方法来解释闭包。</p> <h1 id="我从来不理解-javascript-闭包-直到有人这样向我解释它"><a href="#我从来不理解-javascript-闭包-直到有人这样向我解释它" class="header-anchor">#</a> 我从来不理解 JavaScript 闭包，直到有人这样向我解释它</h1> <h2 id="准备"><a href="#准备" class="header-anchor">#</a> 准备</h2> <p>在理解闭包之前，有个重要的概念需要先了解一下，就是 js 执行上下文。</p> <p>这篇<a href="https://link.juejin.cn/?target=http%3A%2F%2Fdavidshariff.com%2Fblog%2Fwhat-is-the-execution-context-in-javascript%2F" title="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener noreferrer">文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是执行上下文 很不错的入门教程，文章中提到：</p> <blockquote><p>当代码在 JavaScript 中运行时，执行代码的环境非常重要，并将概括为以下几点：</p> <p><strong>全局作用域</strong>——第一次执行代码的默认环境。</p> <p><strong>函数作用域</strong>——当执行流进入函数体时。</p></blockquote> <blockquote><p>(…) —— 我们当作 执行上下文 是当前代码执行的一个环境与作用域。</p></blockquote> <p>换句话说，当我们启动程序时，我们从全局执行上下文中开始。一些变量是在全局执行上下文中声明的。我们称之为全局变量。当程序调用一个函数时，会发生什么?</p> <p>以下几个步骤：</p> <ol><li>JavaScript 创建一个新的执行上下文，我们叫作本地执行上下文。</li> <li>这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。</li> <li>新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</li></ol> <p>函数什么时候结束?当它遇到一个<code>return</code>语句或一个结束括号<code>}</code>。</p> <p>当一个函数结束时，会发生以下情况:</p> <ol><li>这个本地执行上下文从执行堆栈中弹出。</li> <li>函数将返回值返回调用上下文。调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有<code>return</code>语句，则返回<code>undefined</code>。</li> <li>这个本地执行上下文被销毁，销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。</li></ol> <h4 id="基础的例子"><a href="#基础的例子" class="header-anchor">#</a> 基础的例子</h4> <p>在讨论闭包之前，让我们看一下下面的代码：</p> <div class="language- extra-class"><pre class="language-text"><code>1: let a = 3
2: function addTwo(x) {
3:   let ret = x + 2
4:   return ret
5: }
6: let b = addTwo(a)
7: console.log(b)
</code></pre></div><p>为了理解 JavaScript 引擎是如何工作的，让我们详细分析一下：</p> <ol><li>在第<code>1</code>行，我们在全局执行上下文中声明了一个新变量<code>a</code>，并将赋值为<code>3</code>。</li> <li>接下来就变得棘手了，第<code>2</code>行到第<code>5</code>行实际上是在一起的。这里发生了什么? 我们在全局执行上下文中声明了一个名为<code>addTwo</code>的新变量,我们给它分配了什么?一个函数定义。两个括号<code>{}</code>之间的任何内容都被分配给<code>addTwo</code>，函数内部的代码没有被求值，没有被执行，只是存储在一个变量中以备将来使用。</li> <li>现在我们在第<code>6</code>行。它看起来很简单，但是这里有很多东西需要拆开分析。首先，我们在全局执行上下文中声明一个新变量，并将其标记为<code>b</code>，变量一经声明，其值即为<code>undefined</code>。</li> <li>接下来，仍然在第<code>6</code>行，我们看到一个赋值操作符。我们准备给变量<code>b</code>赋一个新值，接下来我们看到一个函数被调用。当看到一个变量后面跟着一个圆括号<code>(…)</code>时，这就是调用函数的信号，接着，每个函数都返回一些东西(值、对象或 undefined)，无论从函数返回什么，都将赋值给变量<code>b</code>。</li> <li>但是首先我们需要调用<code>addTwo</code>的函数。JavaScript 将在其全局执行上下文内存中查找名为<code>addTwo</code>的变量。噢，它找到了一个，它是在步骤 2(或第 2 - 5 行)中定义的。变量<code>add2</code>包含一个函数定义。注意，变量<code>a</code>作为参数传递给函数。JavaScript 在全局执行上下文内存中搜索变量<code>a</code>，找到它，发现它的值是<code>3</code>，并将数字<code>3</code>作为参数传递给函数，准备好执行函数。</li> <li>现在执行上下文将切换,创建了一个新的本地执行上下文，我们将其命名为“addTwo 执行上下文”，执行上下文被推送到调用堆栈上。在<code>addTwo</code>执行上下文中，我们要做的第一件事是什么?</li> <li>你可能会说，“在<code>addTwo</code>执行上下文中声明了一个新的变量<code>ret</code>”，这是不对的。正确的答案是，我们需要先看函数的参数。在<code>addTwo</code>执行上下文中声明一个新的变量``x```，因为值<code>3</code>是作为参数传递的，所以变量<code>x</code>被赋值为 3。</li> <li>下一步是:在<code>addTwo</code>执行上下文中声明一个新的变量<code>ret</code>。它的值被设置为 <code>undefined</code>(第三行)。</li> <li>仍然是第 3 行，需要执行一个相加操作。首先我们需要<code>x</code>的值，JavaScript 会寻找一个变量<code>x</code>，它会首先在<code>addTwo</code>执行上下文中寻找，找到了一个值为<code>3</code>。第二个操作数是数字<code>2</code>。两个相加结果为<code>5</code>就被分配给变量<code>ret</code>。</li> <li>第<code>4</code>行，我们返回变量<code>ret</code>的内容，在 addTwo 执行上下文中查找，找到值为<code>5</code>，返回，函数结束。</li> <li>第<code>4-5</code>行，函数结束。addTwo 执行上下文被销毁，变量<code>x</code>和<code>ret</code>被释放，它们已经不存在了。addTwo 执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数<code>addTwo</code>是从全局执行上下文调用的。</li> <li>现在我们继续第<code>4</code>步的内容，返回值 5 被分配给变量<code>b</code>，程序仍然在第<code>6</code>行。</li> <li>在第 7 行，<code>b</code>的值 5 被打印到控制台了。</li></ol> <p>对于一个非常简单的程序，这是一个非常冗长的解释，我们甚至还没有涉及闭包。但肯定会涉及的，不过首先我们得绕一两个弯。</p> <h2 id="词法作用域-lexical-scope"><a href="#词法作用域-lexical-scope" class="header-anchor">#</a> 词法作用域（Lexical scope）</h2> <p>我们需要理解词法作用域的一些知识。请看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>1: let val1 = 2
2: function multiplyThis(n) {
3:   let ret = n * val1
4:   return ret
5: }
6: let multiplied = multiplyThis(6)
7: console.log('example of scope:', multiplied)

</code></pre></div><p>这里想说明，我们在函数执行上下文中有变量，在全局执行上下文中有变量。JavaScript 的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止。(如果最后找不到，它就是 <code>undefined</code>)。</p> <p>下面列出向个步骤来解释一下（如果你已经熟悉了，请跳过）：</p> <ol><li>在全局执行上下文中声明一个新的变量<code>val1</code>，并将其赋值为<code>2</code>。</li> <li>第<code>2-5</code>行，声明一个新的变量 <code>multiplyThis</code>，并给它分配一个函数定义。</li> <li>第<code>6</code>行，声明一个在全局执行上下文 <code>multiplied</code> 新变量。</li> <li>从全局执行上下文内存中查找变量<code>multiplyThis</code>，并将其作为函数执行，传递数字 <code>6</code> 作为参数。</li> <li>新函数调用(创建新执行上下文），创建一个新的 <code>multiplyThis</code> 函数执行上下文。</li> <li>在 <code>multiplyThis</code> 执行上下文中，声明一个变量<code>n</code>并将其赋值为<code>6</code>。</li> <li>第 <code>3</code> 行。在<code>multiplyThis</code>执行上下文中，声明一个变量<code>ret</code>。</li> <li>继续第 <code>3</code> 行。对两个操作数 <code>n</code> 和 <code>val1</code> 进行乘法运算.在<code>multiplyThis</code>执行上下文中查找变量 <code>n</code>。我们在步骤 6 中声明了它,它的内容是数字<code>6</code>。在<code>multiplyThis</code>执行上下文中查找变量<code>val1</code>。<code>multiplyThis</code>执行上下文没有一个标记为 <code>val1</code> 的变量。我们向调用上下文查找，调用上下文是全局执行上下文，在全局执行上下文中寻找 <code>val1</code>。哦，是的、在那儿，它在步骤 1 中定义，数值是<code>2</code>。</li> <li>继续第 <code>3</code> 行。将两个操作数相乘并将其赋值给<code>ret</code>变量，6 * 2 = 12，ret 现在值为 <code>12</code>。</li> <li>返回<code>ret</code>变量，销毁<code>multiplyThis</code>执行上下文及其变量 <code>ret</code> 和 <code>n</code> 。变量 <code>val1</code> 没有被销毁，因为它是全局执行上下文的一部分。</li> <li>回到第<code>6</code>行。在调用上下文中，数字 <code>12</code> 赋值给 <code>multiplied</code> 的变量。</li> <li>最后在第<code>7</code>行，我们在控制台中打印 <code>multiplied</code> 变量的值</li></ol> <p>在这个例子中，我们需要记住一个函数可以访问在它的调用上下文中定义的变量，这个就是<strong>词法作用域（Lexical scope）</strong> 。</p> <h2 id="返回函数的函数"><a href="#返回函数的函数" class="header-anchor">#</a> 返回函数的函数</h2> <p>在第一个例子中，函数<code>addTwo</code>返回一个数字。请记住，函数可以返回任何东西。让我们看一个返回函数的函数示例，因为这对于理解闭包非常重要。看粟子：</p> <div class="language- extra-class"><pre class="language-text"><code> 1: let val = 7
 2: function createAdder() {
 3:   function addNumbers(a, b) {
 4:     let ret = a + b
 5:     return ret
 6:   }
 7:   return addNumbers
 8: }
 9: let adder = createAdder()
10: let sum = adder(val, 8)
11: console.log('example of function returning a function: ', sum)

</code></pre></div><p>让我们回到分步分解：</p> <ol><li>第<code>1</code>行。我们在全局执行上下文中声明一个变量<code>val</code>并赋值为 <code>7</code>。</li> <li>第 <code>2-8</code> 行。我们在全局执行上下文中声明了一个名为 <code>createAdder</code> 的变量，并为其分配了一个函数定义。第<code>3-7</code>行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到那个变量(<code>createAdder</code>)中。</li> <li>第<code>9</code>行。我们在全局执行上下文中声明了一个名为 <code>adder</code> 的新变量，暂时，值为 <code>undefined</code>。</li> <li>第<code>9</code>行。我们看到括号<code>()</code>，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为<code>createAdder</code> 的变量，它是在步骤<code>2</code>中创建的。好吧，我们调用它。</li> <li>调用函数时，执行到第<code>2</code>行。创建一个新的<code>createAdder</code>执行上下文。我们可以在<code>createAdder</code>的执行上下文中创建自有变量。js 引擎将<code>createAdder</code>的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分.</li> <li>第 <code>3-6</code> 行。我们有一个新的函数声明，我们在<code>createAdder</code>执行上下文中创建一个变量<code>addNumbers</code>。这很重要，<code>addnumber</code>只存在于<code>createAdder</code>执行上下文中。我们将函数定义存储在名为 ``addNumbers``` 的自有变量中。</li> <li>第<code>7</code>行，我们返回变量<code>addNumbers</code>的内容。js 引擎查找一个名为<code>addNumbers</code>的变量并找到它，这是一个函数定义。好的，函数可以返回任何东西，包括函数定义。我们返<code>addNumbers</code>的定义。第<code>4</code>行和第<code>5</code>行括号之间的内容构成该函数定义。</li> <li>返回时，<code>createAdder</code>执行上下文将被销毁。<code>addNumbers</code> 变量不再存在。但<code>addNumbers</code>函数定义仍然存在，因为它返回并赋值给了<code>adder</code> 变量。</li> <li>第<code>10</code>行。我们在全局执行上下文中定义了一个新的变量 <code>sum</code>，先赋值为 <code>undefined</code>;</li> <li>接下来我们需要执行一个函数。哪个函数? 是名为<code>adder</code>变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。</li> <li>让我们查找这两个参数，第一个是我们在步骤 1 中定义的变量<code>val</code>，它表示数字<code>7</code>，第二个是数字<code>8</code>。</li> <li>现在我们要执行这个函数，函数定义概述在第<code>3-5</code>行，因为这个函数是匿名，为了方便理解，我们暂且叫它<code>adder</code>吧。这时创建一个<code>adder</code>函数执行上下文，在<code>adder</code>执行上下文中创建了两个新变量 <code>a</code> 和 <code>b</code>。它们分别被赋值为 <code>7</code> 和 <code>8</code>，因为这些是我们在上一步传递给函数的参数。</li> <li>第 <code>4</code> 行。在<code>adder</code>执行上下文中声明了一个名为<code>ret</code>的新变量,</li> <li>第 <code>4</code> 行。将变量<code>a</code>的内容和变量<code>b</code>的内容相加得<code>15</code>并赋给<code>ret</code>变量。</li> <li><code>ret</code>变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量<code>a</code>、<code>b</code>和<code>ret</code>不再存在。</li> <li>返回值被分配给我们在步骤 9 中定义的<code>sum</code>变量。</li> <li>我们将<code>sum</code>的值打印到控制台。</li> <li>如预期，控制台将打印<code>15</code>。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到<code>return</code>或右括号<code>}</code>时执行完成。</li></ol> <h2 id="最后-一个闭包"><a href="#最后-一个闭包" class="header-anchor">#</a> 最后,一个闭包</h2> <p>看看下面的代码，并试着弄清楚会发生什么。</p> <div class="language- extra-class"><pre class="language-text"><code> 1: function createCounter() {
 2:   let counter = 0
 3:   const myFunction = function() {
 4:     counter = counter + 1
 5:     return counter
 6:   }
 7:   return myFunction
 8: }
 9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)

</code></pre></div><p>现在，我们已经从前两个示例中掌握了它的诀窍，让我们按照预期的方式快速执行它：</p> <ol><li>第 <code>1-8</code> 行。我们在全局执行上下文中创建了一个新的变量<code>createCounter</code>，并赋值了一个的函数定义。</li> <li>第<code>9</code>行。我们在全局执行上下文中声明了一个名为<code>increment</code>的新变量。</li> <li>第<code>9</code>行。我们需要调用<code>createCounter</code>函数并将其返回值赋给<code>increment</code>变量。</li> <li>第 <code>1-8</code>行。调用函数，创建新的本地执行上下文。</li> <li>第<code>2</code>行。在本地执行上下文中，声明一个名为<code>counter</code>的新变量并赋值为 <code>0</code>;</li> <li>第 <code>3-6</code>行。声明一个名为<code>myFunction</code>的新变量，变量在本地执行上下文中声明,变量的内容是为第<code>4</code>行和第 5 行所定义。</li> <li>第 7 行。返回<code>myFunction</code>变量的内容，删除本地执行上下文。变量<code>myFunction</code>和<code>counter</code>不再存在。此时控制权回到了调用上下文。</li> <li>第<code>9</code>行。在调用上下文(全局执行上下文)中，<code>createCounter</code>返回的值赋给了<code>increment</code>，变量<code>increment</code>现在包含一个函数定义内容为<code>createCounter</code>返回的函数。它不再标记为<code>myFunction````，但它的定义是相同的。在全局上下文中，它是的标记为</code>labeledincrement```。</li> <li>第<code>10</code>行。声明一个新变量 <code>c1</code>。</li> <li>继续第<code>10</code>行。查找<code>increment</code>变量，它是一个函数并调用它。它包含前面返回的函数定义，如第<code>4-5</code>行所定义的。</li> <li>创建一个新的执行上下文。没有参数，开始执行函数。</li> <li>第<code>4</code>行。<code>counter=counter + 1</code>。在本地执行上下文中查找<code>counter</code>变量。我们只是创建了那个上下文，从来没有声明任何局部变量。让我们看看全局执行上下文。这里也没有<code>counter</code>变量。Javascript 会将其计算为 counter = undefined + 1，声明一个标记为<code>counter</code>的新局部变量，并将其赋值为 number 1，因为 undefined 被当作值为 0。</li> <li>第<code>5</code>行。我们变量<code>counter</code>的值 <code>1</code>，我们销毁本地执行上下文和<code>counter</code>变量。</li> <li>回到第<code>10</code>行。返回值<code>1</code>被赋给<code>c1</code>。</li> <li>第<code>11</code>行。重复步骤<code>10-14</code>，<code>c2</code>也被赋值为<code>1</code>。</li> <li>第<code>12</code>行。重复步骤<code>10-14</code>，<code>c3</code>也被赋值为<code>1</code>。</li> <li>第<code>13</code>行。我们打印变量<code>c1 c2</code>和<code>c3</code>的内容。</li></ol> <p>你自己试试，看看会发生什么。你会将注意到，它并不像从我上面的解释中所期望的那样记录<code>1,1,1</code>。而是记录<code>1,2,3</code>。这个是为什么?</p> <p>不知怎么滴，<code>increment</code>函数记住了那个<code>cunter</code>的值。这是怎么回事?</p> <p><code>counter</code>是全局执行上下文的一部分吗?尝试 <code>console.log(counter)</code>，得到<code>undefined</code>的结果,显然不是这样的。</p> <p>也许，当你调用<code>increment</code>时，它会以某种方式返回它创建的函数(createCounter)?这怎么可能呢?变量<code>increment</code>包含函数定义，而不是函数的来源，显然也不是这样的。</p> <p>所以一定有另一种机制。<strong>闭包</strong>，我们终于找到了，丢失的那块。</p> <p><strong>它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。</strong></p> <p>所以我们上面的解释都是错的，让我们再试一次，但是这次是正确的。</p> <div class="language- extra-class"><pre class="language-text"><code> 1: function createCounter() {
 2:   let counter = 0
 3:   const myFunction = function() {
 4:     counter = counter + 1
 5:     return counter
 6:   }
 7:   return myFunction
 8: }
 9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)

</code></pre></div><ol><li>同上，第<code>1-8</code>行。我们在全局执行上下文中创建了一个新的变量<code>createCounter</code>，它得到了指定的函数定义。</li> <li>同上，第<code>9</code>行。我们在全局执行上下文中声明了一个名为<code>increment</code>的新变量。</li> <li>同上，第<code>9</code>行。我们需要调用<code>createCounter</code>函数并将其返回值赋给<code>increment</code>变量。</li> <li>同上，第<code>1-8</code>行。调用函数，创建新的本地执行上下文。</li> <li>同上，第<code>2</code>行。在本地执行上下文中，声明一个名为<code>counter</code>的新变量并赋值为 <code>0</code> 。</li> <li>第<code>3-6</code>行。声明一个名为<code>myFunction</code>的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第<code>4</code>行和第<code>5</code>行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量<code>counter</code>(值为<code>0</code>)。</li> <li>第<code>7</code>行。返回<code>myFunction</code>变量的内容,删除本地执行上下文。<code>myFunction</code>和<code>counter</code>不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。</li> <li>第<code>9</code>行。在调用上下文(全局执行上下文)中，<code>createCounter</code>返回的值被指定为<code>increment</code>，变量<code>increment</code>现在包含一个函数定义(和闭包),由 createCounter 返回的函数定义,它不再标记为<code>myFunction</code>，但它的定义是相同的,在全局上下文中，称为<code>increment</code>。</li> <li>第<code>10</code>行。声明一个新变量<code>c1</code>。</li> <li>继续第<code>10</code>行。查找变量<code>increment</code>，它是一个函数，调用它。它包含前面返回的函数定义,如第<code>4-5</code>行所定义的。(它还有一个带有变量的闭包)。</li> <li>创建一个新的执行上下文，没有参数，开始执行函数。</li> <li>第<code>4</code>行。<code>counter = counter + 1</code>，寻找变量 <code>counter</code>，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为<code>counter</code>的变量，其值为<code>0</code>。在第<code>4</code>行表达式之后，它的值被设置为<code>1</code>。它再次被储存在闭包里，闭包现在包含值为<code>1</code>的变量 <code>counter</code>。</li> <li>第<code>5</code>行。我们返回<code>counter的值</code>，销毁本地执行上下文。</li> <li>回到第<code>10</code>行。返回值<code>1</code>被赋给变量<code>c1</code>。</li> <li>第<code>11</code>行。我们重复步骤<code>10-14</code>。这一次，在闭包中此时变量<code>counter</code>的值是 1。它在第<code>12</code>行设置的，它的值被递增并以<code>2</code>的形式存储在递增函数的闭包中,<code>c2</code>被赋值为<code>2</code>。</li> <li>第<code>12</code>行。重复步骤<code>10-14</code>行,<code>c3</code>被赋值为 3。</li> <li>第 13 行。我们打印变量<code>c1 c2</code>和<code>c3</code>的值。</li></ol> <p>你可能会问，是否有任何函数具有闭包，甚至是在全局范围内创建的函数?答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。</p> <p>当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。</p> <h2 id="闭包不是那么简单"><a href="#闭包不是那么简单" class="header-anchor">#</a> 闭包不是那么简单</h2> <p>有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例，如下面的代码所示：</p> <div class="language- extra-class"><pre class="language-text"><code>let c = 4
const addX = x =&gt; n =&gt; n + x
const addThree = addX(3)
let d = addThree(c)
console.log('example partial application', d)

</code></pre></div><p>如果箭头函数让你感到困惑，下面是同样效果：</p> <div class="language- extra-class"><pre class="language-text"><code>let c = 4
function addX(x) {
  return function(n) {
     return n + x
  }
}
const addThree = addX(3)
let d = addThree(c)
console.log('example partial application', d)

</code></pre></div><p>我们声明一个能用加法函数<code>addX</code>，它接受一个参数<code>x</code>并返回另一个函数。返回的函数还接受一个参数并将其添加到变量<code>x</code>中。</p> <p>变量<code>x</code>是闭包的一部分，当变量<code>addThree</code>在本地上下文中声明时，它被分配一个函数定义和一个闭包，闭包包含变量<code>x</code>。</p> <p>所以当<code>addThree</code>被调用并执行时，它可以从闭包中访问变量<code>x</code>以及为参数传递变量<code>n</code>并返回两者的和 <code>7</code>。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>我将永远记住闭包的方法是通过背包的类比。当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。</p> <p><strong>代码部署后可能存在的 BUG 没法实时知道，事后为了解决这些 BUG，花了大量的时间进行 log 调试，这边顺便给大家推荐一个好用的 BUG 监控工具 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.fundebug.com%2F%3Futm_source%3Dxiaozhi" title="https://www.fundebug.com/?utm_source=xiaozhi" target="_blank" rel="noopener noreferrer">Fundebug<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/lan-blog-vuepress/guide/" class="prev router-link-active">
        js
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/lan-blog-vuepress/assets/js/app.f42ab384.js" defer></script><script src="/lan-blog-vuepress/assets/js/2.f6fab634.js" defer></script><script src="/lan-blog-vuepress/assets/js/9.6294dd7e.js" defer></script>
  </body>
</html>
