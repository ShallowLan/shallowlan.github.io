(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{367:function(v,_,e){"use strict";e.r(_);var c=e(44),o=Object(c.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("blockquote",[e("p",[v._v("原文："),e("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fmedium.com%2Fdailyjs%2Fi-never-understood-javascript-closures-9663703368e8",title:"https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8",target:"_blank",rel:"noopener noreferrer"}},[v._v("medium.com/dailyjs/i-n…"),e("OutboundLink")],1)])]),v._v(" "),e("p",[v._v("正如标题所述，JavaScript 闭包对我来说一直有点神秘,看过很多闭包的文章，在工作使用过闭包，有时甚至在项目中使用闭包，但我确实是这是在使用闭包的知识。")]),v._v(" "),e("p",[v._v("最近看到的一些文章，终于，有人用于一种让我明白方式对闭包进行了解释，我将在本文中尝试使用这种方法来解释闭包。")]),v._v(" "),e("h1",{attrs:{id:"我从来不理解-javascript-闭包-直到有人这样向我解释它"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我从来不理解-javascript-闭包-直到有人这样向我解释它"}},[v._v("#")]),v._v(" 我从来不理解 JavaScript 闭包，直到有人这样向我解释它")]),v._v(" "),e("h2",{attrs:{id:"准备"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#准备"}},[v._v("#")]),v._v(" 准备")]),v._v(" "),e("p",[v._v("在理解闭包之前，有个重要的概念需要先了解一下，就是 js 执行上下文。")]),v._v(" "),e("p",[v._v("这篇"),e("a",{attrs:{href:"https://link.juejin.cn/?target=http%3A%2F%2Fdavidshariff.com%2Fblog%2Fwhat-is-the-execution-context-in-javascript%2F",title:"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/",target:"_blank",rel:"noopener noreferrer"}},[v._v("文章"),e("OutboundLink")],1),v._v("是执行上下文 很不错的入门教程，文章中提到：")]),v._v(" "),e("blockquote",[e("p",[v._v("当代码在 JavaScript 中运行时，执行代码的环境非常重要，并将概括为以下几点：")]),v._v(" "),e("p",[e("strong",[v._v("全局作用域")]),v._v("——第一次执行代码的默认环境。")]),v._v(" "),e("p",[e("strong",[v._v("函数作用域")]),v._v("——当执行流进入函数体时。")])]),v._v(" "),e("blockquote",[e("p",[v._v("(…) —— 我们当作 执行上下文 是当前代码执行的一个环境与作用域。")])]),v._v(" "),e("p",[v._v("换句话说，当我们启动程序时，我们从全局执行上下文中开始。一些变量是在全局执行上下文中声明的。我们称之为全局变量。当程序调用一个函数时，会发生什么?")]),v._v(" "),e("p",[v._v("以下几个步骤：")]),v._v(" "),e("ol",[e("li",[v._v("JavaScript 创建一个新的执行上下文，我们叫作本地执行上下文。")]),v._v(" "),e("li",[v._v("这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。")]),v._v(" "),e("li",[v._v("新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。")])]),v._v(" "),e("p",[v._v("函数什么时候结束?当它遇到一个"),e("code",[v._v("return")]),v._v("语句或一个结束括号"),e("code",[v._v("}")]),v._v("。")]),v._v(" "),e("p",[v._v("当一个函数结束时，会发生以下情况:")]),v._v(" "),e("ol",[e("li",[v._v("这个本地执行上下文从执行堆栈中弹出。")]),v._v(" "),e("li",[v._v("函数将返回值返回调用上下文。调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有"),e("code",[v._v("return")]),v._v("语句，则返回"),e("code",[v._v("undefined")]),v._v("。")]),v._v(" "),e("li",[v._v("这个本地执行上下文被销毁，销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。")])]),v._v(" "),e("h4",{attrs:{id:"基础的例子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础的例子"}},[v._v("#")]),v._v(" 基础的例子")]),v._v(" "),e("p",[v._v("在讨论闭包之前，让我们看一下下面的代码：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("1: let a = 3\n2: function addTwo(x) {\n3:   let ret = x + 2\n4:   return ret\n5: }\n6: let b = addTwo(a)\n7: console.log(b)\n")])])]),e("p",[v._v("为了理解 JavaScript 引擎是如何工作的，让我们详细分析一下：")]),v._v(" "),e("ol",[e("li",[v._v("在第"),e("code",[v._v("1")]),v._v("行，我们在全局执行上下文中声明了一个新变量"),e("code",[v._v("a")]),v._v("，并将赋值为"),e("code",[v._v("3")]),v._v("。")]),v._v(" "),e("li",[v._v("接下来就变得棘手了，第"),e("code",[v._v("2")]),v._v("行到第"),e("code",[v._v("5")]),v._v("行实际上是在一起的。这里发生了什么? 我们在全局执行上下文中声明了一个名为"),e("code",[v._v("addTwo")]),v._v("的新变量,我们给它分配了什么?一个函数定义。两个括号"),e("code",[v._v("{}")]),v._v("之间的任何内容都被分配给"),e("code",[v._v("addTwo")]),v._v("，函数内部的代码没有被求值，没有被执行，只是存储在一个变量中以备将来使用。")]),v._v(" "),e("li",[v._v("现在我们在第"),e("code",[v._v("6")]),v._v("行。它看起来很简单，但是这里有很多东西需要拆开分析。首先，我们在全局执行上下文中声明一个新变量，并将其标记为"),e("code",[v._v("b")]),v._v("，变量一经声明，其值即为"),e("code",[v._v("undefined")]),v._v("。")]),v._v(" "),e("li",[v._v("接下来，仍然在第"),e("code",[v._v("6")]),v._v("行，我们看到一个赋值操作符。我们准备给变量"),e("code",[v._v("b")]),v._v("赋一个新值，接下来我们看到一个函数被调用。当看到一个变量后面跟着一个圆括号"),e("code",[v._v("(…)")]),v._v("时，这就是调用函数的信号，接着，每个函数都返回一些东西(值、对象或 undefined)，无论从函数返回什么，都将赋值给变量"),e("code",[v._v("b")]),v._v("。")]),v._v(" "),e("li",[v._v("但是首先我们需要调用"),e("code",[v._v("addTwo")]),v._v("的函数。JavaScript 将在其全局执行上下文内存中查找名为"),e("code",[v._v("addTwo")]),v._v("的变量。噢，它找到了一个，它是在步骤 2(或第 2 - 5 行)中定义的。变量"),e("code",[v._v("add2")]),v._v("包含一个函数定义。注意，变量"),e("code",[v._v("a")]),v._v("作为参数传递给函数。JavaScript 在全局执行上下文内存中搜索变量"),e("code",[v._v("a")]),v._v("，找到它，发现它的值是"),e("code",[v._v("3")]),v._v("，并将数字"),e("code",[v._v("3")]),v._v("作为参数传递给函数，准备好执行函数。")]),v._v(" "),e("li",[v._v("现在执行上下文将切换,创建了一个新的本地执行上下文，我们将其命名为“addTwo 执行上下文”，执行上下文被推送到调用堆栈上。在"),e("code",[v._v("addTwo")]),v._v("执行上下文中，我们要做的第一件事是什么?")]),v._v(" "),e("li",[v._v("你可能会说，“在"),e("code",[v._v("addTwo")]),v._v("执行上下文中声明了一个新的变量"),e("code",[v._v("ret")]),v._v("”，这是不对的。正确的答案是，我们需要先看函数的参数。在"),e("code",[v._v("addTwo")]),v._v("执行上下文中声明一个新的变量``x```，因为值"),e("code",[v._v("3")]),v._v("是作为参数传递的，所以变量"),e("code",[v._v("x")]),v._v("被赋值为 3。")]),v._v(" "),e("li",[v._v("下一步是:在"),e("code",[v._v("addTwo")]),v._v("执行上下文中声明一个新的变量"),e("code",[v._v("ret")]),v._v("。它的值被设置为 "),e("code",[v._v("undefined")]),v._v("(第三行)。")]),v._v(" "),e("li",[v._v("仍然是第 3 行，需要执行一个相加操作。首先我们需要"),e("code",[v._v("x")]),v._v("的值，JavaScript 会寻找一个变量"),e("code",[v._v("x")]),v._v("，它会首先在"),e("code",[v._v("addTwo")]),v._v("执行上下文中寻找，找到了一个值为"),e("code",[v._v("3")]),v._v("。第二个操作数是数字"),e("code",[v._v("2")]),v._v("。两个相加结果为"),e("code",[v._v("5")]),v._v("就被分配给变量"),e("code",[v._v("ret")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("4")]),v._v("行，我们返回变量"),e("code",[v._v("ret")]),v._v("的内容，在 addTwo 执行上下文中查找，找到值为"),e("code",[v._v("5")]),v._v("，返回，函数结束。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("4-5")]),v._v("行，函数结束。addTwo 执行上下文被销毁，变量"),e("code",[v._v("x")]),v._v("和"),e("code",[v._v("ret")]),v._v("被释放，它们已经不存在了。addTwo 执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数"),e("code",[v._v("addTwo")]),v._v("是从全局执行上下文调用的。")]),v._v(" "),e("li",[v._v("现在我们继续第"),e("code",[v._v("4")]),v._v("步的内容，返回值 5 被分配给变量"),e("code",[v._v("b")]),v._v("，程序仍然在第"),e("code",[v._v("6")]),v._v("行。")]),v._v(" "),e("li",[v._v("在第 7 行，"),e("code",[v._v("b")]),v._v("的值 5 被打印到控制台了。")])]),v._v(" "),e("p",[v._v("对于一个非常简单的程序，这是一个非常冗长的解释，我们甚至还没有涉及闭包。但肯定会涉及的，不过首先我们得绕一两个弯。")]),v._v(" "),e("h2",{attrs:{id:"词法作用域-lexical-scope"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域-lexical-scope"}},[v._v("#")]),v._v(" 词法作用域（Lexical scope）")]),v._v(" "),e("p",[v._v("我们需要理解词法作用域的一些知识。请看下面的例子：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("1: let val1 = 2\n2: function multiplyThis(n) {\n3:   let ret = n * val1\n4:   return ret\n5: }\n6: let multiplied = multiplyThis(6)\n7: console.log('example of scope:', multiplied)\n\n")])])]),e("p",[v._v("这里想说明，我们在函数执行上下文中有变量，在全局执行上下文中有变量。JavaScript 的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止。(如果最后找不到，它就是 "),e("code",[v._v("undefined")]),v._v(")。")]),v._v(" "),e("p",[v._v("下面列出向个步骤来解释一下（如果你已经熟悉了，请跳过）：")]),v._v(" "),e("ol",[e("li",[v._v("在全局执行上下文中声明一个新的变量"),e("code",[v._v("val1")]),v._v("，并将其赋值为"),e("code",[v._v("2")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("2-5")]),v._v("行，声明一个新的变量 "),e("code",[v._v("multiplyThis")]),v._v("，并给它分配一个函数定义。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("6")]),v._v("行，声明一个在全局执行上下文 "),e("code",[v._v("multiplied")]),v._v(" 新变量。")]),v._v(" "),e("li",[v._v("从全局执行上下文内存中查找变量"),e("code",[v._v("multiplyThis")]),v._v("，并将其作为函数执行，传递数字 "),e("code",[v._v("6")]),v._v(" 作为参数。")]),v._v(" "),e("li",[v._v("新函数调用(创建新执行上下文），创建一个新的 "),e("code",[v._v("multiplyThis")]),v._v(" 函数执行上下文。")]),v._v(" "),e("li",[v._v("在 "),e("code",[v._v("multiplyThis")]),v._v(" 执行上下文中，声明一个变量"),e("code",[v._v("n")]),v._v("并将其赋值为"),e("code",[v._v("6")]),v._v("。")]),v._v(" "),e("li",[v._v("第 "),e("code",[v._v("3")]),v._v(" 行。在"),e("code",[v._v("multiplyThis")]),v._v("执行上下文中，声明一个变量"),e("code",[v._v("ret")]),v._v("。")]),v._v(" "),e("li",[v._v("继续第 "),e("code",[v._v("3")]),v._v(" 行。对两个操作数 "),e("code",[v._v("n")]),v._v(" 和 "),e("code",[v._v("val1")]),v._v(" 进行乘法运算.在"),e("code",[v._v("multiplyThis")]),v._v("执行上下文中查找变量 "),e("code",[v._v("n")]),v._v("。我们在步骤 6 中声明了它,它的内容是数字"),e("code",[v._v("6")]),v._v("。在"),e("code",[v._v("multiplyThis")]),v._v("执行上下文中查找变量"),e("code",[v._v("val1")]),v._v("。"),e("code",[v._v("multiplyThis")]),v._v("执行上下文没有一个标记为 "),e("code",[v._v("val1")]),v._v(" 的变量。我们向调用上下文查找，调用上下文是全局执行上下文，在全局执行上下文中寻找 "),e("code",[v._v("val1")]),v._v("。哦，是的、在那儿，它在步骤 1 中定义，数值是"),e("code",[v._v("2")]),v._v("。")]),v._v(" "),e("li",[v._v("继续第 "),e("code",[v._v("3")]),v._v(" 行。将两个操作数相乘并将其赋值给"),e("code",[v._v("ret")]),v._v("变量，6 * 2 = 12，ret 现在值为 "),e("code",[v._v("12")]),v._v("。")]),v._v(" "),e("li",[v._v("返回"),e("code",[v._v("ret")]),v._v("变量，销毁"),e("code",[v._v("multiplyThis")]),v._v("执行上下文及其变量 "),e("code",[v._v("ret")]),v._v(" 和 "),e("code",[v._v("n")]),v._v(" 。变量 "),e("code",[v._v("val1")]),v._v(" 没有被销毁，因为它是全局执行上下文的一部分。")]),v._v(" "),e("li",[v._v("回到第"),e("code",[v._v("6")]),v._v("行。在调用上下文中，数字 "),e("code",[v._v("12")]),v._v(" 赋值给 "),e("code",[v._v("multiplied")]),v._v(" 的变量。")]),v._v(" "),e("li",[v._v("最后在第"),e("code",[v._v("7")]),v._v("行，我们在控制台中打印 "),e("code",[v._v("multiplied")]),v._v(" 变量的值")])]),v._v(" "),e("p",[v._v("在这个例子中，我们需要记住一个函数可以访问在它的调用上下文中定义的变量，这个就是"),e("strong",[v._v("词法作用域（Lexical scope）")]),v._v(" 。")]),v._v(" "),e("h2",{attrs:{id:"返回函数的函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#返回函数的函数"}},[v._v("#")]),v._v(" 返回函数的函数")]),v._v(" "),e("p",[v._v("在第一个例子中，函数"),e("code",[v._v("addTwo")]),v._v("返回一个数字。请记住，函数可以返回任何东西。让我们看一个返回函数的函数示例，因为这对于理解闭包非常重要。看粟子：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v(" 1: let val = 7\n 2: function createAdder() {\n 3:   function addNumbers(a, b) {\n 4:     let ret = a + b\n 5:     return ret\n 6:   }\n 7:   return addNumbers\n 8: }\n 9: let adder = createAdder()\n10: let sum = adder(val, 8)\n11: console.log('example of function returning a function: ', sum)\n\n")])])]),e("p",[v._v("让我们回到分步分解：")]),v._v(" "),e("ol",[e("li",[v._v("第"),e("code",[v._v("1")]),v._v("行。我们在全局执行上下文中声明一个变量"),e("code",[v._v("val")]),v._v("并赋值为 "),e("code",[v._v("7")]),v._v("。")]),v._v(" "),e("li",[v._v("第 "),e("code",[v._v("2-8")]),v._v(" 行。我们在全局执行上下文中声明了一个名为 "),e("code",[v._v("createAdder")]),v._v(" 的变量，并为其分配了一个函数定义。第"),e("code",[v._v("3-7")]),v._v("行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到那个变量("),e("code",[v._v("createAdder")]),v._v(")中。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("9")]),v._v("行。我们在全局执行上下文中声明了一个名为 "),e("code",[v._v("adder")]),v._v(" 的新变量，暂时，值为 "),e("code",[v._v("undefined")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("9")]),v._v("行。我们看到括号"),e("code",[v._v("()")]),v._v("，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为"),e("code",[v._v("createAdder")]),v._v(" 的变量，它是在步骤"),e("code",[v._v("2")]),v._v("中创建的。好吧，我们调用它。")]),v._v(" "),e("li",[v._v("调用函数时，执行到第"),e("code",[v._v("2")]),v._v("行。创建一个新的"),e("code",[v._v("createAdder")]),v._v("执行上下文。我们可以在"),e("code",[v._v("createAdder")]),v._v("的执行上下文中创建自有变量。js 引擎将"),e("code",[v._v("createAdder")]),v._v("的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分.")]),v._v(" "),e("li",[v._v("第 "),e("code",[v._v("3-6")]),v._v(" 行。我们有一个新的函数声明，我们在"),e("code",[v._v("createAdder")]),v._v("执行上下文中创建一个变量"),e("code",[v._v("addNumbers")]),v._v("。这很重要，"),e("code",[v._v("addnumber")]),v._v("只存在于"),e("code",[v._v("createAdder")]),v._v("执行上下文中。我们将函数定义存储在名为 ``addNumbers``` 的自有变量中。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("7")]),v._v("行，我们返回变量"),e("code",[v._v("addNumbers")]),v._v("的内容。js 引擎查找一个名为"),e("code",[v._v("addNumbers")]),v._v("的变量并找到它，这是一个函数定义。好的，函数可以返回任何东西，包括函数定义。我们返"),e("code",[v._v("addNumbers")]),v._v("的定义。第"),e("code",[v._v("4")]),v._v("行和第"),e("code",[v._v("5")]),v._v("行括号之间的内容构成该函数定义。")]),v._v(" "),e("li",[v._v("返回时，"),e("code",[v._v("createAdder")]),v._v("执行上下文将被销毁。"),e("code",[v._v("addNumbers")]),v._v(" 变量不再存在。但"),e("code",[v._v("addNumbers")]),v._v("函数定义仍然存在，因为它返回并赋值给了"),e("code",[v._v("adder")]),v._v(" 变量。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("10")]),v._v("行。我们在全局执行上下文中定义了一个新的变量 "),e("code",[v._v("sum")]),v._v("，先赋值为 "),e("code",[v._v("undefined")]),v._v(";")]),v._v(" "),e("li",[v._v("接下来我们需要执行一个函数。哪个函数? 是名为"),e("code",[v._v("adder")]),v._v("变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。")]),v._v(" "),e("li",[v._v("让我们查找这两个参数，第一个是我们在步骤 1 中定义的变量"),e("code",[v._v("val")]),v._v("，它表示数字"),e("code",[v._v("7")]),v._v("，第二个是数字"),e("code",[v._v("8")]),v._v("。")]),v._v(" "),e("li",[v._v("现在我们要执行这个函数，函数定义概述在第"),e("code",[v._v("3-5")]),v._v("行，因为这个函数是匿名，为了方便理解，我们暂且叫它"),e("code",[v._v("adder")]),v._v("吧。这时创建一个"),e("code",[v._v("adder")]),v._v("函数执行上下文，在"),e("code",[v._v("adder")]),v._v("执行上下文中创建了两个新变量 "),e("code",[v._v("a")]),v._v(" 和 "),e("code",[v._v("b")]),v._v("。它们分别被赋值为 "),e("code",[v._v("7")]),v._v(" 和 "),e("code",[v._v("8")]),v._v("，因为这些是我们在上一步传递给函数的参数。")]),v._v(" "),e("li",[v._v("第 "),e("code",[v._v("4")]),v._v(" 行。在"),e("code",[v._v("adder")]),v._v("执行上下文中声明了一个名为"),e("code",[v._v("ret")]),v._v("的新变量,")]),v._v(" "),e("li",[v._v("第 "),e("code",[v._v("4")]),v._v(" 行。将变量"),e("code",[v._v("a")]),v._v("的内容和变量"),e("code",[v._v("b")]),v._v("的内容相加得"),e("code",[v._v("15")]),v._v("并赋给"),e("code",[v._v("ret")]),v._v("变量。")]),v._v(" "),e("li",[e("code",[v._v("ret")]),v._v("变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量"),e("code",[v._v("a")]),v._v("、"),e("code",[v._v("b")]),v._v("和"),e("code",[v._v("ret")]),v._v("不再存在。")]),v._v(" "),e("li",[v._v("返回值被分配给我们在步骤 9 中定义的"),e("code",[v._v("sum")]),v._v("变量。")]),v._v(" "),e("li",[v._v("我们将"),e("code",[v._v("sum")]),v._v("的值打印到控制台。")]),v._v(" "),e("li",[v._v("如预期，控制台将打印"),e("code",[v._v("15")]),v._v("。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到"),e("code",[v._v("return")]),v._v("或右括号"),e("code",[v._v("}")]),v._v("时执行完成。")])]),v._v(" "),e("h2",{attrs:{id:"最后-一个闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最后-一个闭包"}},[v._v("#")]),v._v(" 最后,一个闭包")]),v._v(" "),e("p",[v._v("看看下面的代码，并试着弄清楚会发生什么。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v(" 1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log('example increment', c1, c2, c3)\n\n")])])]),e("p",[v._v("现在，我们已经从前两个示例中掌握了它的诀窍，让我们按照预期的方式快速执行它：")]),v._v(" "),e("ol",[e("li",[v._v("第 "),e("code",[v._v("1-8")]),v._v(" 行。我们在全局执行上下文中创建了一个新的变量"),e("code",[v._v("createCounter")]),v._v("，并赋值了一个的函数定义。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("9")]),v._v("行。我们在全局执行上下文中声明了一个名为"),e("code",[v._v("increment")]),v._v("的新变量。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("9")]),v._v("行。我们需要调用"),e("code",[v._v("createCounter")]),v._v("函数并将其返回值赋给"),e("code",[v._v("increment")]),v._v("变量。")]),v._v(" "),e("li",[v._v("第 "),e("code",[v._v("1-8")]),v._v("行。调用函数，创建新的本地执行上下文。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("2")]),v._v("行。在本地执行上下文中，声明一个名为"),e("code",[v._v("counter")]),v._v("的新变量并赋值为 "),e("code",[v._v("0")]),v._v(";")]),v._v(" "),e("li",[v._v("第 "),e("code",[v._v("3-6")]),v._v("行。声明一个名为"),e("code",[v._v("myFunction")]),v._v("的新变量，变量在本地执行上下文中声明,变量的内容是为第"),e("code",[v._v("4")]),v._v("行和第 5 行所定义。")]),v._v(" "),e("li",[v._v("第 7 行。返回"),e("code",[v._v("myFunction")]),v._v("变量的内容，删除本地执行上下文。变量"),e("code",[v._v("myFunction")]),v._v("和"),e("code",[v._v("counter")]),v._v("不再存在。此时控制权回到了调用上下文。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("9")]),v._v("行。在调用上下文(全局执行上下文)中，"),e("code",[v._v("createCounter")]),v._v("返回的值赋给了"),e("code",[v._v("increment")]),v._v("，变量"),e("code",[v._v("increment")]),v._v("现在包含一个函数定义内容为"),e("code",[v._v("createCounter")]),v._v("返回的函数。它不再标记为"),e("code",[v._v("myFunction````，但它的定义是相同的。在全局上下文中，它是的标记为")]),v._v("labeledincrement```。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("10")]),v._v("行。声明一个新变量 "),e("code",[v._v("c1")]),v._v("。")]),v._v(" "),e("li",[v._v("继续第"),e("code",[v._v("10")]),v._v("行。查找"),e("code",[v._v("increment")]),v._v("变量，它是一个函数并调用它。它包含前面返回的函数定义，如第"),e("code",[v._v("4-5")]),v._v("行所定义的。")]),v._v(" "),e("li",[v._v("创建一个新的执行上下文。没有参数，开始执行函数。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("4")]),v._v("行。"),e("code",[v._v("counter=counter + 1")]),v._v("。在本地执行上下文中查找"),e("code",[v._v("counter")]),v._v("变量。我们只是创建了那个上下文，从来没有声明任何局部变量。让我们看看全局执行上下文。这里也没有"),e("code",[v._v("counter")]),v._v("变量。Javascript 会将其计算为 counter = undefined + 1，声明一个标记为"),e("code",[v._v("counter")]),v._v("的新局部变量，并将其赋值为 number 1，因为 undefined 被当作值为 0。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("5")]),v._v("行。我们变量"),e("code",[v._v("counter")]),v._v("的值 "),e("code",[v._v("1")]),v._v("，我们销毁本地执行上下文和"),e("code",[v._v("counter")]),v._v("变量。")]),v._v(" "),e("li",[v._v("回到第"),e("code",[v._v("10")]),v._v("行。返回值"),e("code",[v._v("1")]),v._v("被赋给"),e("code",[v._v("c1")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("11")]),v._v("行。重复步骤"),e("code",[v._v("10-14")]),v._v("，"),e("code",[v._v("c2")]),v._v("也被赋值为"),e("code",[v._v("1")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("12")]),v._v("行。重复步骤"),e("code",[v._v("10-14")]),v._v("，"),e("code",[v._v("c3")]),v._v("也被赋值为"),e("code",[v._v("1")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("13")]),v._v("行。我们打印变量"),e("code",[v._v("c1 c2")]),v._v("和"),e("code",[v._v("c3")]),v._v("的内容。")])]),v._v(" "),e("p",[v._v("你自己试试，看看会发生什么。你会将注意到，它并不像从我上面的解释中所期望的那样记录"),e("code",[v._v("1,1,1")]),v._v("。而是记录"),e("code",[v._v("1,2,3")]),v._v("。这个是为什么?")]),v._v(" "),e("p",[v._v("不知怎么滴，"),e("code",[v._v("increment")]),v._v("函数记住了那个"),e("code",[v._v("cunter")]),v._v("的值。这是怎么回事?")]),v._v(" "),e("p",[e("code",[v._v("counter")]),v._v("是全局执行上下文的一部分吗?尝试 "),e("code",[v._v("console.log(counter)")]),v._v("，得到"),e("code",[v._v("undefined")]),v._v("的结果,显然不是这样的。")]),v._v(" "),e("p",[v._v("也许，当你调用"),e("code",[v._v("increment")]),v._v("时，它会以某种方式返回它创建的函数(createCounter)?这怎么可能呢?变量"),e("code",[v._v("increment")]),v._v("包含函数定义，而不是函数的来源，显然也不是这样的。")]),v._v(" "),e("p",[v._v("所以一定有另一种机制。"),e("strong",[v._v("闭包")]),v._v("，我们终于找到了，丢失的那块。")]),v._v(" "),e("p",[e("strong",[v._v("它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。")])]),v._v(" "),e("p",[v._v("所以我们上面的解释都是错的，让我们再试一次，但是这次是正确的。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v(" 1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log('example increment', c1, c2, c3)\n\n")])])]),e("ol",[e("li",[v._v("同上，第"),e("code",[v._v("1-8")]),v._v("行。我们在全局执行上下文中创建了一个新的变量"),e("code",[v._v("createCounter")]),v._v("，它得到了指定的函数定义。")]),v._v(" "),e("li",[v._v("同上，第"),e("code",[v._v("9")]),v._v("行。我们在全局执行上下文中声明了一个名为"),e("code",[v._v("increment")]),v._v("的新变量。")]),v._v(" "),e("li",[v._v("同上，第"),e("code",[v._v("9")]),v._v("行。我们需要调用"),e("code",[v._v("createCounter")]),v._v("函数并将其返回值赋给"),e("code",[v._v("increment")]),v._v("变量。")]),v._v(" "),e("li",[v._v("同上，第"),e("code",[v._v("1-8")]),v._v("行。调用函数，创建新的本地执行上下文。")]),v._v(" "),e("li",[v._v("同上，第"),e("code",[v._v("2")]),v._v("行。在本地执行上下文中，声明一个名为"),e("code",[v._v("counter")]),v._v("的新变量并赋值为 "),e("code",[v._v("0")]),v._v(" 。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("3-6")]),v._v("行。声明一个名为"),e("code",[v._v("myFunction")]),v._v("的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第"),e("code",[v._v("4")]),v._v("行和第"),e("code",[v._v("5")]),v._v("行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量"),e("code",[v._v("counter")]),v._v("(值为"),e("code",[v._v("0")]),v._v(")。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("7")]),v._v("行。返回"),e("code",[v._v("myFunction")]),v._v("变量的内容,删除本地执行上下文。"),e("code",[v._v("myFunction")]),v._v("和"),e("code",[v._v("counter")]),v._v("不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("9")]),v._v("行。在调用上下文(全局执行上下文)中，"),e("code",[v._v("createCounter")]),v._v("返回的值被指定为"),e("code",[v._v("increment")]),v._v("，变量"),e("code",[v._v("increment")]),v._v("现在包含一个函数定义(和闭包),由 createCounter 返回的函数定义,它不再标记为"),e("code",[v._v("myFunction")]),v._v("，但它的定义是相同的,在全局上下文中，称为"),e("code",[v._v("increment")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("10")]),v._v("行。声明一个新变量"),e("code",[v._v("c1")]),v._v("。")]),v._v(" "),e("li",[v._v("继续第"),e("code",[v._v("10")]),v._v("行。查找变量"),e("code",[v._v("increment")]),v._v("，它是一个函数，调用它。它包含前面返回的函数定义,如第"),e("code",[v._v("4-5")]),v._v("行所定义的。(它还有一个带有变量的闭包)。")]),v._v(" "),e("li",[v._v("创建一个新的执行上下文，没有参数，开始执行函数。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("4")]),v._v("行。"),e("code",[v._v("counter = counter + 1")]),v._v("，寻找变量 "),e("code",[v._v("counter")]),v._v("，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为"),e("code",[v._v("counter")]),v._v("的变量，其值为"),e("code",[v._v("0")]),v._v("。在第"),e("code",[v._v("4")]),v._v("行表达式之后，它的值被设置为"),e("code",[v._v("1")]),v._v("。它再次被储存在闭包里，闭包现在包含值为"),e("code",[v._v("1")]),v._v("的变量 "),e("code",[v._v("counter")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("5")]),v._v("行。我们返回"),e("code",[v._v("counter的值")]),v._v("，销毁本地执行上下文。")]),v._v(" "),e("li",[v._v("回到第"),e("code",[v._v("10")]),v._v("行。返回值"),e("code",[v._v("1")]),v._v("被赋给变量"),e("code",[v._v("c1")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("11")]),v._v("行。我们重复步骤"),e("code",[v._v("10-14")]),v._v("。这一次，在闭包中此时变量"),e("code",[v._v("counter")]),v._v("的值是 1。它在第"),e("code",[v._v("12")]),v._v("行设置的，它的值被递增并以"),e("code",[v._v("2")]),v._v("的形式存储在递增函数的闭包中,"),e("code",[v._v("c2")]),v._v("被赋值为"),e("code",[v._v("2")]),v._v("。")]),v._v(" "),e("li",[v._v("第"),e("code",[v._v("12")]),v._v("行。重复步骤"),e("code",[v._v("10-14")]),v._v("行,"),e("code",[v._v("c3")]),v._v("被赋值为 3。")]),v._v(" "),e("li",[v._v("第 13 行。我们打印变量"),e("code",[v._v("c1 c2")]),v._v("和"),e("code",[v._v("c3")]),v._v("的值。")])]),v._v(" "),e("p",[v._v("你可能会问，是否有任何函数具有闭包，甚至是在全局范围内创建的函数?答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。")]),v._v(" "),e("p",[v._v("当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。")]),v._v(" "),e("h2",{attrs:{id:"闭包不是那么简单"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包不是那么简单"}},[v._v("#")]),v._v(" 闭包不是那么简单")]),v._v(" "),e("p",[v._v("有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例，如下面的代码所示：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("let c = 4\nconst addX = x => n => n + x\nconst addThree = addX(3)\nlet d = addThree(c)\nconsole.log('example partial application', d)\n\n")])])]),e("p",[v._v("如果箭头函数让你感到困惑，下面是同样效果：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("let c = 4\nfunction addX(x) {\n  return function(n) {\n     return n + x\n  }\n}\nconst addThree = addX(3)\nlet d = addThree(c)\nconsole.log('example partial application', d)\n\n")])])]),e("p",[v._v("我们声明一个能用加法函数"),e("code",[v._v("addX")]),v._v("，它接受一个参数"),e("code",[v._v("x")]),v._v("并返回另一个函数。返回的函数还接受一个参数并将其添加到变量"),e("code",[v._v("x")]),v._v("中。")]),v._v(" "),e("p",[v._v("变量"),e("code",[v._v("x")]),v._v("是闭包的一部分，当变量"),e("code",[v._v("addThree")]),v._v("在本地上下文中声明时，它被分配一个函数定义和一个闭包，闭包包含变量"),e("code",[v._v("x")]),v._v("。")]),v._v(" "),e("p",[v._v("所以当"),e("code",[v._v("addThree")]),v._v("被调用并执行时，它可以从闭包中访问变量"),e("code",[v._v("x")]),v._v("以及为参数传递变量"),e("code",[v._v("n")]),v._v("并返回两者的和 "),e("code",[v._v("7")]),v._v("。")]),v._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("p",[v._v("我将永远记住闭包的方法是通过背包的类比。当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。")]),v._v(" "),e("p",[e("strong",[v._v("代码部署后可能存在的 BUG 没法实时知道，事后为了解决这些 BUG，花了大量的时间进行 log 调试，这边顺便给大家推荐一个好用的 BUG 监控工具 "),e("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.fundebug.com%2F%3Futm_source%3Dxiaozhi",title:"https://www.fundebug.com/?utm_source=xiaozhi",target:"_blank",rel:"noopener noreferrer"}},[v._v("Fundebug"),e("OutboundLink")],1),v._v("。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);